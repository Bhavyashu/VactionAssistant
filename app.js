const { google } = require('googleapis');
const auth = require('./auth');
const createLabel = require('./createLabel');
const SendReplyEmail = require('./replyGenerator');
const fetchThreads = require('./fetchThreads');

// const repliedEmails = new Set(); // Additional feature: to store the email address of each sender 
// const threadAndEmail = new Map(); // Additional feature: to store IDs and emails of threads

/* ============================= Important Observation ============================================================

1) Each new conversation has a different thread attached to it, and we aim to reply only once to each new conversation.
2) If abc@gmail.com sends a message saying "HI" in the morning, and our automated reply replies to it, and then if they send an email acknowledging the reply, the entire conversation is embedded in a single thread ID.
3) If abc@gmail.com sends a new email, it will be considered a different thread. So, to avoid spamming and generate only one automated reply, we use the `repliedEmails` set to keep track of the emails to which replies have been sent.

================================================================================================================
*/

const threadIdSet = new Set(); // This stores all the unique thread IDs fetched from the Gmail API.
let labelId = null; // To move the email threads to a specific label ID.

/**
 * Process unreplied threads and send them the automated reply.
 *
 * @param {object} gmail - The Gmail API client.
 */
async function processUnrepliedThreads(gmail) {
  const threads = await fetchThreads(gmail, threadIdSet); // Fetch unreplied threads

  if (threads.length === 0) {
    console.log('No new threads found in the inbox.');
  } else {
    for (const thread of threads) {
      const threadId = thread.id;

      // Get the thread that hasn't been replied to
      const threadResponse = await gmail.users.threads.get({
        userId: 'me',
        id: threadId,
      });

      const messages = threadResponse.data.messages;

      if (messages.length > 0) {
        const message = messages[0];
        const fromEmail = message.payload.headers.find((header) => header.name === 'From').value;

        console.log(`Replying to email thread with ID: ${threadId}`);

        const replyStatus = await SendReplyEmail(gmail, fromEmail, message, threadId); // Generate and send the reply

        console.log('Reply sent:', replyStatus.data);
        console.log(`Sent a reply to ${fromEmail} from thread ${threadId}.`);

        const labelId = await createLabel(gmail); // Create or get the label ID
        await gmail.users.threads.modify({
          userId: 'me',
          id: threadId,
          requestBody: {
            addLabelIds: [labelId],
          },
        });

        threadIdSet.add(threadId); // Update the thread ID set

        /* Additional features
        // repliedEmails.add(fromEmail); // To enable only one email reply irrespective of the number of threads generated by the sender
        // threadAndEmail.set(threadId, fromEmail); // Note that the particular sender has been sent the reply, no need to send them again
        */
      }
    }
  }
}

/**
 * Starts the email service by retrieving or generating the access token and initiating the Gmail API client.
 */
async function startEmailService() {
  // Get the token
  const token = auth.retrieveToken();

  if (token) {
    auth.oAuth2Client.setCredentials(token);
  } else {
    const authClient = await auth.getAccessToken();
    auth.oAuth2Client.setCredentials(authClient.credentials);
  }

  const gmail = google.gmail({ version: 'v1', auth: auth.oAuth2Client });

  setInterval(async () => {
    console.log('Fetching new unread and unreplied emails...');
    await processUnrepliedThreads(gmail);
  }, 45000); // Runs every 45 seconds to fetch new unread and unreplied emails
}

function getRandomInterval(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

startEmailService();
